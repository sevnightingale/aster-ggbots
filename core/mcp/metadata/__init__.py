"""
MCP Metadata Module

Provides access to MCP tool metadata and mappings for the crypto indicators MCP.
This metadata is generated by connecting to the MCP server and listing available tools.
"""

import json
from pathlib import Path
from typing import Dict, List, Optional, Any

# Path to this module's directory
METADATA_DIR = Path(__file__).parent

# Load the tool metadata
def load_indicators_metadata() -> List[Dict]:
    """Load the full indicators tool metadata."""
    with open(METADATA_DIR / "indicators_tools.json", "r") as f:
        return json.load(f)

# Load the name mapping
def load_indicator_mapping() -> Dict[str, str]:
    """Load the indicator name mapping."""
    with open(METADATA_DIR / "indicator_name_mapping.json", "r") as f:
        return json.load(f)

# Create a reverse mapping for user-friendly names
def create_friendly_mapping() -> Dict[str, str]:
    """
    Create a mapping from user-friendly names to MCP tool names.
    
    Returns:
        Dict mapping friendly names like "RSI" to "calculate_relative_strength_index"
    """
    tools = load_indicators_metadata()
    
    mapping = {
        # Common abbreviations and friendly names
        "RSI": "calculate_relative_strength_index",
        "MACD": "calculate_moving_average_convergence_divergence",
        "SMA": "calculate_simple_moving_average",
        "EMA": "calculate_exponential_moving_average",
        "BollingerBands": "calculate_bollinger_bands",
        "BB": "calculate_bollinger_bands",
        "ATR": "calculate_average_true_range",
        "CCI": "calculate_commodity_channel_index",
        "Stochastic": "calculate_stochastic_oscillator",
        "StochasticOscillator": "calculate_stochastic_oscillator",
        "Williams%R": "calculate_williams_r",
        "WilliamsR": "calculate_williams_r",
        "SAR": "calculate_parabolic_sar",
        "ParabolicSAR": "calculate_parabolic_sar",
        "PSAR": "calculate_parabolic_sar",
        "OBV": "calculate_on_balance_volume",
        "OnBalanceVolume": "calculate_on_balance_volume",
        "MFI": "calculate_money_flow_index",
        "MoneyFlowIndex": "calculate_money_flow_index",
        "ROC": "calculate_price_rate_of_change",
        "PriceROC": "calculate_price_rate_of_change",
        "CMF": "calculate_chaikin_money_flow",
        "ChaikinMoneyFlow": "calculate_chaikin_money_flow",
        "ADL": "calculate_accumulation_distribution",
        "AccumulationDistribution": "calculate_accumulation_distribution",
        "Aroon": "calculate_aroon",
        "VWAP": "calculate_volume_weighted_average_price",
        "VolumeWeightedAveragePrice": "calculate_volume_weighted_average_price",
        "ForceIndex": "calculate_force_index",
        "KeltnerChannel": "calculate_keltner_channel",
        "DonchianChannel": "calculate_donchian_channel",
        "IchimokuCloud": "calculate_ichimoku_cloud",
        "Ichimoku": "calculate_ichimoku_cloud",
        "BollingerBandsWidth": "calculate_bollinger_bands_width",
        "BBW": "calculate_bollinger_bands_width",
        "Vortex": "calculate_vortex",
        "TRIX": "calculate_triple_exponential_average",
        # Note: ADX is not available in current MCP tools - would need to be added to MCP server
        "ADX": "calculate_average_directional_index",  # Placeholder for when it's implemented
    }
    
    # Also add exact tool names (without "calculate_" prefix)
    for tool in tools:
        name = tool["name"]
        if name.startswith("calculate_") and not name.endswith("_strategy"):
            # Extract the indicator name part
            indicator_part = name[10:]  # Remove "calculate_"
            
            # Add CamelCase version
            camel_case = ''.join(word.capitalize() for word in indicator_part.split('_'))
            if camel_case not in mapping:
                mapping[camel_case] = name
    
    return mapping

# Cache the mappings
_indicators_metadata = None
_indicator_mapping = None
_friendly_mapping = None

def get_indicators_metadata() -> List[Dict]:
    """Get cached indicators metadata."""
    global _indicators_metadata
    if _indicators_metadata is None:
        _indicators_metadata = load_indicators_metadata()
    return _indicators_metadata

def get_indicator_mapping() -> Dict[str, str]:
    """Get cached indicator name mapping."""
    global _indicator_mapping
    if _indicator_mapping is None:
        _indicator_mapping = load_indicator_mapping()
    return _indicator_mapping

def get_friendly_mapping() -> Dict[str, str]:
    """Get cached friendly name mapping."""
    global _friendly_mapping
    if _friendly_mapping is None:
        _friendly_mapping = create_friendly_mapping()
    return _friendly_mapping

def get_mcp_tool_name(indicator_name: str) -> Optional[str]:
    """
    Get the MCP tool name for a given indicator.
    
    Args:
        indicator_name: User-friendly indicator name (e.g., "RSI", "MACD")
        
    Returns:
        MCP tool name (e.g., "calculate_relative_strength_index") or None if not found
    """
    mapping = get_friendly_mapping()
    
    # Try exact match first
    if indicator_name in mapping:
        return mapping[indicator_name]
    
    # Try case-insensitive match
    lower_name = indicator_name.lower()
    for key, value in mapping.items():
        if key.lower() == lower_name:
            return value
    
    # Try checking the raw tool names
    raw_mapping = get_indicator_mapping()
    if indicator_name in raw_mapping:
        return raw_mapping[indicator_name]
    
    return None

def parse_indicator_string(indicator_string: str) -> Dict[str, Any]:
    """
    Parse string-based indicators into components.
    
    Examples:
        "RSI_1h" → {"indicator": "RSI", "timeframe": "1h"}
        "DonchianChannel_200_4h" → {"indicator": "DonchianChannel", "period": 200, "timeframe": "4h"}
        "BollingerBandsWidth_1h" → {"indicator": "BollingerBandsWidth", "timeframe": "1h"}
        "RSI" → {"indicator": "RSI"}  # Backwards compatibility
    
    Args:
        indicator_string: String indicator specification
        
    Returns:
        Dictionary with parsed components
    """
    parts = indicator_string.split('_')
    result = {"indicator": parts[0]}
    
    # Valid timeframes
    valid_timeframes = ['1m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '12h', '1d', '1w']
    
    # Parse remaining parts for period and timeframe
    for part in parts[1:]:
        if part.isdigit():
            result["period"] = int(part)
        elif part in valid_timeframes:
            result["timeframe"] = part
    
    return result

def get_mcp_tool_name_from_string(indicator_string: str) -> Optional[str]:
    """
    Get MCP tool name from string-based indicator.
    
    Args:
        indicator_string: String indicator like "RSI_4h" or "DonchianChannel_200_1h"
        
    Returns:
        MCP tool name or None if not found
    """
    parsed = parse_indicator_string(indicator_string)
    return get_mcp_tool_name(parsed["indicator"])

def get_tool_info(mcp_tool_name: str) -> Optional[Dict]:
    """
    Get full tool information for a given MCP tool name.
    
    Args:
        mcp_tool_name: Full MCP tool name
        
    Returns:
        Tool information dict or None if not found
    """
    tools = get_indicators_metadata()
    for tool in tools:
        if tool["name"] == mcp_tool_name:
            return tool
    return None

def get_available_indicators() -> List[str]:
    """
    Get a list of all available user-friendly indicator names.
    
    Returns:
        List of indicator names that can be used in configuration
    """
    mapping = get_friendly_mapping()
    return sorted(list(mapping.keys()))

# For convenience, export the main lookup function
__all__ = [
    'get_mcp_tool_name',
    'get_mcp_tool_name_from_string',
    'parse_indicator_string',
    'get_tool_info',
    'get_available_indicators',
    'get_indicators_metadata',
    'get_friendly_mapping'
]